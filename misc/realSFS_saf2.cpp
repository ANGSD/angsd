
#include "realSFS.h"


size_t calcNsitesBanded(const char *fname,int nChr);
void readGLBanded(gzFile gz,size_t nSites,int nChr,Matrix<double> &ret);



extern size_t nSites;
extern int doBFGS;//defaults is to use EM-optimization
extern int calcLike;
extern int SIG_COND;
/*
  loads first 8bytes and checks magic value
  //returns 1 if it is new format
  //return 0 if it is old format
 */

int isNewFormat(const char *fname){
  gzFile gz=Z_NULL;
  gz = gzopen(fname,"r");
  if(gz==Z_NULL){
    fprintf(stderr,"Problem opening file: \'%s\'",fname);
    exit(0);
  }
  char buf[8];
  gzread(gz,buf,8*sizeof(char));
  //if(0==strcmp(buf,"safv2"))
  //  fprintf(stderr,"File is new format... Opening string is: %s\n",buf);
  gzclose(gz);
  return (0==strcmp(buf,"safv2"));
}


typedef struct{
  int offset;  // first discrete count at which we specify non-zero site
               // likelihood values
  int len;  // # of elements specified with non-zero likelihood
  double *llh;
}aSite;



int main_1dsfs_v2(const char * fname1, int chr1,long int nSites,int nThreads,char *sfsfname,double tole,int maxIter){

  bool BandedInput;

  if(isNewFormat(fname1)){
    BandedInput=1;
  }else{
    fprintf(stderr,"This version of realSFS only works with the banded output generated by doSaf2 angsd functions.\n");
    return 1;
  }

  if(nSites==0){//if no -nSites is specified
    if(fsize(fname1)>getTotalSystemMemory())
      fprintf(stderr,"Looks like you will allocate too much memory, consider starting the program with a lower -nSites argument\n");

    // [JN] Calc Nsites conditional on file format
    if(BandedInput)
      nSites=calcNsitesBanded(fname1,chr1);
    else
      nSites=calcNsites(fname1,chr1);
  }


  fprintf(stderr,"fname1:%s nChr:%d startsfs:%s nThreads:%d tole=%f maxIter=%d nSites=%lu\n",fname1,chr1,sfsfname,nThreads,tole,maxIter,nSites);

  // [JN] Note: in future we can reduce memory usage for banded format but
  // requires replacing Matrix<double> for GL1 with a class that
  // will act like Matrix<double> for purposes of lik/em1/bfgs but
  // have compressed version of matrix under the hood.  For now doing the simple
  // thing and will fill GL1 with zeroes outside of banded area, so mem usage
  // identical to original

  float bytes_req_megs = nSites*(sizeof(double)*(chr1+1)+sizeof(double*))/1024/1024;
  float mem_avail_megs = getTotalSystemMemory()/1024/1024;//in percentile
  //  fprintf(stderr,"en:%zu to:%f\n",bytes_req_megs,mem_avail_megs);
  fprintf(stderr,"The choice of -nSites will require atleast: %f megabyte memory, that is approx: %.2f%% of total memory\n",bytes_req_megs,bytes_req_megs*100/mem_avail_megs);

  int dim;
  dim=chr1+1;
  gzFile gz1;
  Matrix<double> GL1;
  GL1=alloc(nSites,dim);
  gz1=getGz(fname1);
  // Skip filetype safv2 string
  gzseek(gz1,8*sizeof(char),SEEK_SET);
  

  double *sfs=new double[dim];

  while(1){

    if(BandedInput){
      // [JN] To be finished...
      // GL1 is matrix class with .x = nSites .y = nChr+1
      readGLBanded(gz1,nSites,chr1,GL1);
    }else{
      readGL(gz1,nSites,chr1,GL1);
    }
#if 0
    for(int s=0;s<GL1.x;s++)
      fwrite(GL1.mat[s],sizeof(double),GL1.y,stdout);
    exit(0);
#endif

    if(GL1.x==0)
      break;
    fprintf(stderr,"dim(GL1)=%zu,%zu\n",GL1.x,GL1.y);



    if(sfsfname!=NULL){
      readSFS(sfsfname,dim,sfs);
    }else{

      for(int i=0;i<dim;i++)
	sfs[i] = (i+1)/((double)dim);
      if(doBFGS){
	double ts=1;
	for(int i=0;i<dim-1;i++)
	  ts += 0.01/(1.0+i);
	sfs[0]=1.0/ts;
	for(int i=0;i<dim-1;i++)
	  sfs[i+1]  = (0.01/(1.0+i))/ts;
      }
      normalize(sfs,dim);
    }
    //  em2_smart(sfs2,pops,1e-6,1e3);
    setThreadPars(&GL1,NULL,sfs,nThreads);
    if(calcLike==0){
      if(doBFGS==0)
	em1(sfs,&GL1,tole,maxIter);
      else
	bfgs(sfs,&GL1);
    }
    double lik;
    if(nThreads>1)
      lik = lik1_master();
    else
      lik = lik1(sfs,&GL1,0,GL1.x);

    fprintf(stderr,"likelihood: %f\n",lik);
#if 1
    for(int x=0;x<dim;x++)
      fprintf(stdout,"%f ",log(sfs[x]));
    fprintf(stdout,"\n");
    fflush(stdout);
#endif
  }
  dalloc(GL1,nSites);
  gzclose(gz1);
  delete [] sfs;
  return 0;
}

// [JN] Function to calc Nsites from new safv2 file format
// Note the new format encodes Nsites per "chunk"
// so we need to loop through chunks summing Nsites
size_t calcNsitesBanded(const char *fname,int nChr){
  size_t nSites=0;
  int offset;
  int len;
  gzFile gz=Z_NULL;
  if(((gz=gzopen(fname,"r")))==Z_NULL){
    fprintf(stderr,"Problem opening file: \'%s\'\n",fname);
    exit(0);
  }

  // Skip filetype safv2 string.
  gzseek(gz,8*sizeof(char),SEEK_SET);
  while(gzread(gz,&offset,sizeof(int))){
    gzread(gz,&len,sizeof(int));
    gzseek(gz,len*sizeof(double),SEEK_CUR);
    nSites++;
  }

  return nSites;
}


void readGLBanded(gzFile gz,size_t nSites,int nChr,Matrix<double> &ret){
  size_t s=0;
  int offset;
  int len;
  ret.x=s;
  ret.y=nChr+1;




  // While still reading in all sites
  while(SIG_COND&&s<nSites&&gzread(gz,&offset,sizeof(int))){
      
      gzread(gz,&len,sizeof(int));

      // Initialize all values below offset
      for(int i=0;i<offset;i++)
        ret.mat[s][i]=0.0;

      // Set the len values starting from offset based on file
      gzread(gz,ret.mat[s]+offset,sizeof(double)*len);
      // Exponentiate values in band
      for(int i=offset;i<offset+len;i++)
        ret.mat[s][i]=exp(ret.mat[s][i]);

      // Initialize all values to the "right" of the band
      for(int i=offset+len;i<nChr+1;i++)
        ret.mat[s][i]=0.0;

      s++;
  } // Finish loop
  fprintf(stderr,"done reading ret.x=s=%zu\n",s );
  ret.x=s;
  //if we killed program lets exit
  if(SIG_COND==0)
    exit(0);

}

